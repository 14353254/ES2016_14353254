##lab4 Deadlock死锁  
###一、实验流程  
1.将PPT上的关于死锁的代码敲到Deadlock.java文件中，代码如下图所示
![Deadlock.java文件](https://ooo.0o0.ooo/2016/11/01/5818768cb3e4c.jpg)  
2.在cmd中运行，首先进入到Deadlock.java文件的路径中，输入指令javac Deadlock.java编译java文件，生成.class文件  
3.Windows系统下，将PPT上的Deadlock.bat文件的内容敲到记事本里，然后保存为Deadlock.bat。代码如下  
![Deadlock.bat文件内容](https://ooo.0o0.ooo/2016/11/01/5818768ca2142.png)  
4.然后将该批处理文件放在java程序（Deadlock.class）目录下，双击运行，观察结果（该批处理文件的目的就是让这个程序跑一百遍，通常情况下，
跑个几十遍就会停，多少次停是随机的，调节程序中count值，使其发生死锁。）
发生死锁时的运行截图如下所示，运行到第218次时发生死锁：  
![死锁结果](https://ooo.0o0.ooo/2016/11/01/58187aec70771.png)  
###二、实验分析  
**1.分析上述程序出现死锁的原因:**  
在Deadlock.java文件中，将函数的类型用关键字synchronized申明了，当用该关键字修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多
只有一个线程执行该段代码；当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步
代码块或同步方法的访问将被阻塞。所以当本次实验的Deadlock程序运行时，a.methodA(b)执行时需要访问class B的代码段，b.methodB(a) 执行时
需要访问class A的代码段，当这两个处于不同线程的函数同时开始执行时，都会因为请求访问的代码段被占用而同时被阻塞，也就是进入了循环等待，
死锁产生。  
**2.产生死锁的4个条件**  
(1)互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程使用。如果另一进程申请该资源，那么申请进程必须等到该资源被释放为止。  
(2)占有并等待：一个进程必须占有至少一个资源并且正在等待另一个资源，而该资源被其他进程占有。  
(3)非抢占：资源不能被抢占，即资源只能在进程完成任务后自动释放  
(4)循环等待：若干进程之间形成一种头尾相接的循环等待资源关系

